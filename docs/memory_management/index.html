<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory management - Lamp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://pityka.github.io/lamp/favicon.png">

  
  
  <link rel="stylesheet" href="/lamp/css/style.min.ab49f0da65a9bb2e51b43f76fb24346d416717d3205cbd8e2e0bd70b9c811f6c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/lamp/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/lamp/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-api">
      <a href="/lamp/api/">
        <span>API</span>
      </a>
    </li>
    
    <li class="menu-item-code">
      <a href="https://github.com/pityka/lamp">
        <span>Code</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    
    
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/lamp/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/lamp/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-api">
      <a href="/lamp/api/">
        <span>API</span>
      </a>
    </li>
    
    <li class="menu-item-code">
      <a href="https://github.com/pityka/lamp">
        <span>Code</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>

    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <h4>Docs</h4>
  <ul>
    
    <li class="">
      <a href="https://pityka.github.io/lamp/docs/getting_started/">Getting started</a>
    </li>
    
    <li class="">
      <a href="https://pityka.github.io/lamp/docs/usage_overview/">How to build and train a model</a>
    </li>
    
    <li class="active ">
      <a href="https://pityka.github.io/lamp/docs/memory_management/">Memory management</a>
    </li>
    
    <li class="">
      <a href="https://pityka.github.io/lamp/docs/modules/">Defining modules</a>
    </li>
    
  </ul>
</div>
          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Memory management</h1>
<div class="content anchor-link-enabled">
  

<p>Lamp allocates data as ATen tensors which are stored off heap.
Native ATen tensors are exposed to the JVM via the <code>aten.Tensor</code> class.
Each <code>aten.Tensor</code> JVM object is a handle to the tensor - actually handle to native <code>Tensor</code> object which is a handle itself to the tensor&rsquo;s data.</p>

<p>Tensors must be released manually with the <code>aten.Tensor#release</code> or <code>releaseAll</code> methods. A double release might crash the VM.</p>

<h1 id="autograd-variables-and-sten-tensors">autograd Variables and STen tensors</h1>

<p>In contrast with <code>aten.Tensor</code>s <code>lamp.autograd.Variable</code>s and <code>lamp.STen</code>s are managed. Allocation of these require a scope (<code>lamp.Scope</code>) which demarkate the lifetime of the variable.
Autograd variables own up to two tensors: their value and optionally their partial derivatives.</p>

<p><code>lamp.STen</code> is a shallow wrapper around <code>aten.Tensor</code>s. It ensures that an appropriate scope is present
before allocation and it provides a more fluent chainable API.</p>

<p>Example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala mdoc" data-lang="scala mdoc">  def squaredEuclideanDistance(v1: STen, v2: STen)(
      implicit scope: Scope // parent scope
  ): STen = {
    Scope { implicit scope =&gt; // this is a local scope cleared up when block ends
      val outer = v1.mm(v2.t) // these allocations will get released at the end of the block
      val n1 = (v1 * v1).rowSum
      val n2 = (v2 * v2).rowSum
      (n1 + n2.t - outer * 2) 
    } // once the block exits all resources allocated within the block are released, with the exception of the 
      // return value which is moved to the parent scope
  }</code></pre></div>
<p>With IO:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala mdoc" data-lang="scala mdoc">  def squaredEuclideanDistance(v1: STen, v2: STen)(
      implicit parent: Scope // parent scope
  ): IO[STen] = {
    Scope.bracket(parent) { implicit scope =&gt; // this is a local scope cleared up when block ends
      val outer = v1.mm(v2.t) // these allocations will get released at the end of the block
      val n1 = (v1 * v1).rowSum
      val n2 = (v2 * v2).rowSum
      (n1 + n2.t - outer * 2) 
    } // once the block exits all resources allocated within the block are released, with the exception of the 
      // return value which is moved to the parent scope
  }</code></pre></div>
<h1 id="lamp-scope"><code>lamp.Scope</code></h1>

<p>Both <code>STen</code> and <code>Variable</code> own references to <code>aten.Tensor</code>s which need to be managed (released) manually.
The constructors of STen and Variable take an instance of <code>Scope</code> and register the Tensors with the Scope.
A Scope can be released which releases all the registered Tensors.
This simplifies memory management because a <code>Scope</code> instance can be injected into a Scala lexical block and released once the block exits.</p>

<p>A <code>Scope</code> may be built with any of the factory methods in its companion object:</p>

<p><code>Scope.apply</code> , <code>Scope.bracket</code> and <code>Scope.root</code>: these factories take a lambda, thus inject the <code>Scope</code> instance in the lexical scope of the lambda.</p>

<p><code>Scope.apply</code> is meant to be used in scope which itself has a parent scope. It will not release the return value, but move it to its parent scope. Consequently the return type of the lambda it takes are restricted to members of the <code>Movable</code> type class.</p>

<p>The <code>Movable</code> type class provides compile time introspection so that the library can extract the list of Tensors from the return value and move them to the parent scope.
It is defined as</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">Movable</span><span style="color:#f92672">[</span><span style="color:#66d9ef">-R</span><span style="color:#f92672">]</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">def</span> list<span style="color:#f92672">(</span>movable<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">R</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Tensor</span><span style="color:#f92672">]</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>Most regular Scala types and primities have a <code>Movable</code> instance which return the empty list.
<code>lamp.STen</code>, <code>Variable</code>s, and <code>lamp.GenericModule[_,_]</code> are members of the <code>Movable</code> type class.</p>

<p><code>Scope.root</code> is meant to be used as the outermost Scope. It can not return anything, thus it takes a lambda with a Unit return type.</p>

</div>
</div>

        </div>
      </div>
    </div>
  </div>

  

  
  

  
  <script type="text/javascript" src="/lamp/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>